import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;
import retrofit2.http.*;

import java.io.IOException;
import java.util.List;

/**
 * A sample Java client demonstrating how to interact with the Simple E-commerce API.
 * This example uses the Retrofit library for making HTTP requests.
 *
 * To run this, you would need the following Maven dependencies in your pom.xml:
 * <dependencies>
 * * <dependency>
 * <groupId>com.squareup.retrofit2</groupId>
 * <artifactId>retrofit</artifactId>
 * <version>2.9.0</version>
 * </dependency>
 * * <dependency>
 * <groupId>com.squareup.retrofit2</groupId>
 * <artifactId>converter-gson</artifactId>
 * <version>2.9.0</version>
 * </dependency>
 * </dependencies>
 */
public class ApiClient {

    private static final String BASE_URL = "https://api.example.com/v1/";

    // 1. Define the API Interface based on the OpenAPI specification
    public interface ECommerceApiService {

        @GET("products")
        Call<List<Product>> listProducts(@Query("category") String category);

        @GET("products/{productId}")
        Call<Product> getProductById(@Path("productId") String productId);

        @POST("products")
        Call<Product> createProduct(@Body Product newProduct);

        @PUT("products/{productId}")
        Call<Void> updateProduct(@Path("productId") String productId, @Body Product productToUpdate);

        @DELETE("products/{productId}")
        Call<Void> deleteProduct(@Path("productId") String productId);
    }

    // 2. Define the data model (POJO) to match the API's Product schema
    public static class Product {
        // Note: For POST requests, the 'id' can be null as it's generated by the server.
        private String id;
        private String name;
        private String description;
        private double price;
        private String category;
        private int stock;
        
        // Constructor for creating a new product (ID is not needed)
        public Product(String name, String description, double price, String category, int stock) {
            this.name = name;
            this.description = description;
            this.price = price;
            this.category = category;
            this.stock = stock;
        }

        @Override
        public String toString() {
            return "Product{" +
                   "id='" + id + '\'' +
                   ", name='" + name + '\'' +
                   ", price=" + price +
                   ", stock=" + stock +
                   '}';
        }
    }

    // 3. Main method to execute API calls
    public static void main(String[] args) throws IOException {
        // Setup Retrofit
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .build();

        ECommerceApiService apiService = retrofit.create(ECommerceApiService.class);

        System.out.println("--- ðŸš€ EXECUTING API CALLS ---");

        // Example 1: Get a list of all products (synchronous call)
        System.out.println("\n[1] Fetching all products...");
        // Note: In a real app, network calls should not be on the main thread.
        Response<List<Product>> listResponse = apiService.listProducts(null).execute();
        if (listResponse.isSuccessful() && listResponse.body() != null) {
            listResponse.body().forEach(System.out::println);
        } else {
            System.err.println("Failed to fetch products: " + listResponse.code());
        }

        // Example 2: Create a new product (asynchronous call)
        System.out.println("\n[2] Creating a new product...");
        Product newProduct = new Product("Wireless Mouse", "A high-precision wireless mouse", 25.99, "Electronics", 150);
        apiService.createProduct(newProduct).enqueue(new Callback<>() {
            @Override
            public void onResponse(Call<Product> call, Response<Product> response) {
                if (response.isSuccessful() && response.body() != null) {
                    System.out.println("Product created successfully: " + response.body());
                } else {
                    System.err.println("Failed to create product: " + response.code());
                }
            }

            @Override
            public void onFailure(Call<Product> call, Throwable t) {
                System.err.println("An error occurred: " + t.getMessage());
            }
        });
        
        // A short pause to allow the async call to complete before the program exits
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("\n--- âœ… DEMO COMPLETE ---");
    }
}
